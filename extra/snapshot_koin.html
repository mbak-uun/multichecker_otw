<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SNAPSHOT KOIN</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.16.18/dist/css/uikit.min.css" />
  <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/5170/5170907.png" />
  <style>
    body { padding: 10px; }
    .uk-container { max-width: 90%; }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border:1px solid #ddd; border-radius:999px; background:#fafafa; margin:2px; }
    .chip .name { font-weight:700; }
    .muted { color:#777; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .table-wrap { border:1px solid #ddd; border-radius:6px; overflow:auto; }
    .sticky-head thead th { position: sticky; top: 0; z-index: 5; background:#f5f5f5; }
    .uk-form-xxsmall { height:28px; padding:2px 6px; font-size:12px; }
  </style>
</head>
<body>
  <div class="uk-container">
    <h3 class="uk-heading-line"><span>SNAPSHOT KOIN — Checker (CEX × Chain)</span></h3>

    <div class="uk-card uk-card-default uk-card-body">
      <div class="uk-text-bold uk-margin-small"> <button id="btnImportSeed" class="uk-button uk-button-small uk-button-danger" title="Sinkroniasai DATA KOIN KESERVER">🔃</button>Pilih CHAIN & EXCHANGER</div>
      <div class="uk-grid-small uk-margin-small" uk-grid>
        <div class="uk-width-1-3@s">
           
          <select id="chainSelect" class="uk-select">
            <option value="ethereum">ETHEREUM</option>
            <option value="bsc">BSC</option>
            <option value="polygon">POLYGON</option>
            <option value="arbitrum">ARBITRUM</option>
            <option value="base">BASE</option>
          </select>
        </div>
        <div class="uk-width-2-3@s uk-flex uk-flex-middle" style="gap:8px;">
          <button id="btnFetch" class="uk-button uk-button-primary uk-button-small">SYNC KOIN</button>
          <button id="btnLoadLocal" class="uk-button uk-button-secondary uk-button-small">LOAD DATABASE</button>
         
          <button id="btnExport" class="uk-button uk-button-default uk-button-small" disabled>Export CSV</button>
          <button id="btnRpc" class="uk-button uk-button-danger uk-button-small">RPC Settings</button>
          <span id="statusText" class="uk-text-meta"></span>
        </div>
      </div>

      <div class="uk-grid-small" uk-grid>
        <div class="uk-width-1-1">
          <div id="cex-list"></div>
        </div>
      </div>
      <!-- Rate controls: user-configurable delays -->
      <div class="uk-grid-small uk-margin-small uk-flex-middle" uk-grid>
        <div class="uk-width-auto"><span class="uk-text-bold uk-text-meta">Delay (ms):</span></div>
        <div class="uk-width-auto">
          <label class="uk-text-meta">CEX</label>
          <input type="number" id="rateCex" class="uk-input uk-form-xxsmall" style="width:90px;" min="0" value="150">
        </div>
        <div class="uk-width-auto">
          <label class="uk-text-meta">WEB3</label>
          <input type="number" id="rateWeb3" class="uk-input uk-form-xxsmall" style="width:90px;" min="0" value="150">
        </div>
        <div class="uk-width-auto">
          <label class="uk-text-meta">PRICE</label>
          <input type="number" id="ratePrice" class="uk-input uk-form-xxsmall" style="width:90px;" min="0" value="60">
        </div>
      </div>
    </div>

    <div class="uk-flex uk-flex-middle uk-margin-small" id="table-toolbar" style="gap:8px;">
      <input id="tableSearch" class="uk-input uk-form-xxsmall" style="max-width:260px;" placeholder="Search token/symbol/SC/CEX">
      <div id="summaryBadges" class="uk-flex uk-flex-wrap" style="gap:6px;"></div>
    </div>
    <div class="uk-margin-small table-wrap">
      <table class="uk-table uk-table-small uk-table-divider uk-table-hover sticky-head">
        <thead>
          <tr>
            <th>No</th>
            <th>CEX</th>
            <th>Chain</th>
            <th>Nama Token</th>
            <th>Ticker</th>
            <th>SC</th>
            <th>Decimals</th>
            <th>Fee WD</th>
            <th>Trade</th>
            <th>Deposit</th>
            <th>Withdraw</th>
            <th>Price</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <div id="overlay" class="uk-flex uk-flex-middle uk-flex-center" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.45); z-index:9999;">
      <div class="uk-card uk-card-default uk-card-body uk-text-center" style="min-width:360px;">
        <div class="uk-margin-small" uk-spinner="ratio: 1.1"></div>
        <div class="uk-margin-small msg uk-text-bold">Processing...</div>
        <div class="uk-text-meta phase">Phase</div>
        <progress id="ovProgress" class="uk-progress uk-margin-small-top" value="0" max="100"></progress>
        <div class="uk-text-meta counter">0 / 0 (0%)</div>
      </div>
    </div>

  </div>

  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3/dist/web3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.16.18/dist/js/uikit.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="/idb-localstorage-shim.js"></script>
  <!-- RPC Settings Modal -->
  <div id="rpcModal" uk-modal>
    <div class="uk-modal-dialog uk-modal-body">
      <h4 class="uk-margin-small">RPC Settings per Chain</h4>
      <div class="uk-grid-small" uk-grid>
        <div class="uk-width-1-1@s">
          <div class="uk-margin-small"><label class="uk-text-meta">ETHEREUM</label><input id="rpc-ethereum" class="uk-input" placeholder="https://..."></div>
          <div class="uk-margin-small"><label class="uk-text-meta">BSC</label><input id="rpc-bsc" class="uk-input" placeholder="https://..."></div>
          <div class="uk-margin-small"><label class="uk-text-meta">POLYGON</label><input id="rpc-polygon" class="uk-input" placeholder="https://..."></div>
          <div class="uk-margin-small"><label class="uk-text-meta">ARBITRUM</label><input id="rpc-arbitrum" class="uk-input" placeholder="https://..."></div>
          <div class="uk-margin-small"><label class="uk-text-meta">BASE</label><input id="rpc-base" class="uk-input" placeholder="https://..."></div>
        </div>
      </div>
      <div class="uk-text-right uk-margin-small-top">
        <button class="uk-button uk-button-default uk-modal-close" type="button">Close</button>
        <button id="btnSaveRpc" class="uk-button uk-button-primary" type="button">Save</button>
      </div>
      <div class="uk-text-meta uk-margin-small-top">Kosongkan untuk pakai default. Nilai disimpan di Database (IndexedDB) key <b>SNAPSHOT_RPC</b>.</div>
    </div>
  </div>
  <script>
  (async function(){
    if (window.__IDB_LOCALSTORAGE_READY__) {
      try { await window.__IDB_LOCALSTORAGE_READY__; } catch(_){}
    }
    // Compact duplicates (one-time at load)
    try { compactSnapshot(); } catch(_){}
    // Use random proxy prefix from CONFIG_PROXY if available, otherwise fallback
    const getCORS = () => (window.CONFIG_PROXY && window.CONFIG_PROXY.PREFIX) || 'https://proxykanan.awokawok.workers.dev/?';
    const prox = (u) => `${getCORS()}${u}`;
    // Pacing to avoid rate limits (user-configurable)
    let RATE = { CEX_DELAY_MS: 150, WEB3_DELAY_MS: 150, PRICE_DELAY_MS: 60 };
    // Key registry (used for IndexedDB KV)
    const LS_KEYS = {
      RATE: 'SNAPSHOT_RATE',
      SNAPSHOT: 'SNAPSHOT_DATA_KOIN',
      RPC: 'SNAPSHOT_RPC',
      SELECTED_CEX: 'SNAPSHOT_SELECTED_CEX',
      LEGACY_SELECTED_CEX: 'TOOL_SELECTED_CEX'
    };
    // IndexedDB lightweight KV wrapper with in-memory cache
    const IDB_NAME = 'SNAPSHOT_DB';
    const IDB_STORE = 'kv';
    let IDB_DB = null;
    const IDB_CACHE = {}; // { key -> value }
    function safeStringify(obj){ try { return JSON.stringify(obj, (k,v)=> (typeof v==='bigint')? String(v): v); } catch(_) { try{ return JSON.stringify(obj);}catch(__){return '{}';} } }
    function openIDB(){
      return new Promise((resolve, reject)=>{
        try{
          const req = indexedDB.open(IDB_NAME, 1);
          req.onupgradeneeded = function(ev){ const db = ev.target.result; if (!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE, { keyPath:'key' }); };
          req.onsuccess = function(ev){ IDB_DB = ev.target.result; resolve(IDB_DB); };
          req.onerror = function(ev){ reject(ev.target.error || new Error('IDB open failed')); };
        }catch(e){ reject(e); }
      });
    }
    function idbGet(key){
      return new Promise(async (resolve)=>{
        try{
          if (!IDB_DB) await openIDB();
          const tx = IDB_DB.transaction([IDB_STORE], 'readonly');
          const st = tx.objectStore(IDB_STORE);
          const req = st.get(String(key));
          req.onsuccess = function(){ resolve(req.result ? req.result.val : undefined); };
          req.onerror = function(){ resolve(undefined); };
        }catch(_){ resolve(undefined); }
      });
    }
    function idbSet(key, val){
      return new Promise(async (resolve)=>{
        try{
          if (!IDB_DB) await openIDB();
          const tx = IDB_DB.transaction([IDB_STORE], 'readwrite');
          const st = tx.objectStore(IDB_STORE);
          st.put({ key: String(key), val });
          tx.oncomplete = function(){ resolve(true); };
          tx.onerror = function(){ resolve(false); };
        }catch(_){ resolve(false); }
      });
    }
    // Load known keys to cache (best-effort, non-blocking)
    (async function initIDBCache(){
      try{
        const keys = [LS_KEYS.RATE, LS_KEYS.SNAPSHOT, LS_KEYS.RPC, LS_KEYS.SELECTED_CEX];
        for (let i=0;i<keys.length;i++){
          const k = keys[i];
          const v = await idbGet(k);
          if (v !== undefined) { IDB_CACHE[k] = v; continue; }
          // simple migration from localStorage if exists
          try{
            const raw = localStorage.getItem(k);
            if (raw!=null) { const parsed = JSON.parse(raw); IDB_CACHE[k]=parsed; await idbSet(k, parsed); }
          }catch(_){ /* ignore */ }
        }
        try { buildCexChips(); } catch(_){}
      }catch(_){ /* ignore init errors */ }
    })();
    // KV helpers reusing cache; non-throwing
    function trySave(key, val){ IDB_CACHE[key]=val; idbSet(key, val); return true; }
    function loadJSON(key, def){ const v = (IDB_CACHE.hasOwnProperty(key)? IDB_CACHE[key] : undefined); return (v===undefined)? (def||{}) : v; }
    // Rate
    const LS_RATE=LS_KEYS.RATE;
    function loadRate(){ return loadJSON(LS_RATE, {}); }
    function saveRate(obj){ trySave(LS_RATE, obj||{}); }

    // Central config to simplify adding new CEX/Chains
    const DEBUG = false;
    const CEX = {
      BINANCE:{WARNA:'#e0a50c'},
      MEXC:{WARNA:'#1448ce'}, 
      GATE:{WARNA:'#D5006D'},
      KUCOIN:{WARNA:'#29b3af'}, 
      BITGET:{WARNA:'#07f0ff'}, 
      BYBIT:{WARNA:'#f29900'},
      // OKX:{WARNA:'#111'},
      INDODAX:{WARNA:'#1285b5'}
    };
    const CHAINS = {
      ethereum:{ name:'ETHEREUM', RPC:'https://ethereum.publicnode.com' },
      bsc:{ name:'BSC', RPC:'https://bsc-dataseed.binance.org/' },
      polygon:{ name:'POLYGON', RPC:'https://polygon-rpc.com' },
      arbitrum:{ name:'ARBITRUM', RPC:'https://arb1.arbitrum.io/rpc' },
      base:{ name:'BASE', RPC:'https://base.llamarpc.com' }
    };

     // Embedded API keys and NameMap (copied from config_tri.js)
    const CEX_API = {
      BINANCE: { ApiKey: "2U7YGMEUDri6tP3YEzmK3CcZWb9yQ5j3COp9s7pRRUv4vu8hJAlwH4NkbNK74hDU", ApiSecret: "XHjPVjLzbs741xoznV3xz1Wj5SFrcechNBjvezyXLcg8GLWF21VW32f0YhAsQ9pn" },
      MEXC:    { ApiKey: "mx0vglBh22wwHBY0il", ApiSecret: "429877e0b47c41b68dd77613cdfded64" },
      OKX:     { ApiKey: "4d6226e8-c858-42b5-a32e-60b6ce8b4bdc", ApiSecret: "3EB8717DE58187BAE45E282EB0045CE3", ApiPassphrase:"Macpro-2025" },
      GATE:    { ApiKey: "577bb104ebb7977925c0ba7a292a722e", ApiSecret: "48b2cd4b122f076d2ebf8833359dfeffd268c5a0ce276b4cbe6ba5aa52e7f7cc" },
      BYBIT:   { ApiKey: "HnsUDsGJz3wBUWB0yo", ApiSecret: "7oxpgXRQGs7RvkGGoz8mM10drIKPXCVgUW4S" },
      // Optional: INDODAX TAPI (private) for network mapping
      INDODAX: { ApiKey: "HRKOX8GL-KD9ANNF5-T7OKENAH-LHL5PBYQ-NW8GQICL", ApiSecret: "2ff67f7546f9b1af3344f4012fbb5561969de9440f1d1432c89473d1fe007deb3f3d0bac7400622b" }
    };

    // Price sources per CEX (centralized)
    const PRICE_SOURCES = {
      // useProxy: false to bypass proxy if endpoint allows CORS (helps avoid 451)
      BINANCE: { url: 'https://api.binance.com/api/v3/ticker/price',        useProxy: false, parse: r => { const m={}; (r||[]).forEach(it=>{ const s=String(it.symbol||''); if (s.endsWith('USDT')) m[s.replace(/USDT$/,'')] = parseFloat(it.price); }); return m; } },
      MEXC:    { url: 'https://api.mexc.com/api/v3/ticker/price',           useProxy: false, parse: r => { const m={}; (r||[]).forEach(it=>{ const s=String(it.symbol||''); if (s.endsWith('USDT')) m[s.replace(/USDT$/,'')] = parseFloat(it.price); }); return m; } },
      GATE:    { url: 'https://api.gateio.ws/api/v4/spot/tickers',           useProxy: true,  parse: r => { const m={}; (r||[]).forEach(it=>{ const p=String(it.currency_pair||''); if (p.endsWith('_USDT')) m[p.replace(/_USDT$/,'')] = parseFloat(it.last); }); return m; } },
      KUCOIN:  { url: 'https://api.kucoin.com/api/v1/market/allTickers',     useProxy: true,  parse: r => { const m={}; ((r?.data?.ticker)||[]).forEach(it=>{ const s=String(it.symbol||''); if (s.endsWith('-USDT')) m[s.replace(/-USDT$/,'')] = parseFloat(it.last); }); return m; } },
      OKX:     { url: 'https://www.okx.com/api/v5/market/tickers?instType=SPOT', useProxy: true, parse: r => { const m={}; ((r?.data)||[]).forEach(it=>{ const s=String(it.instId||''); if (s.endsWith('-USDT')) m[s.replace(/-USDT$/,'')] = parseFloat(it.last); }); return m; } },
      BITGET:  { url: 'https://api.bitget.com/api/v2/spot/market/tickers',  useProxy: false,  parse: r => { const m={}; ((r?.data)||[]).forEach(it=>{ const s=String(it.symbol||''); if (s.endsWith('USDT')) m[s.replace(/USDT$/,'')] = parseFloat(it.lastPr); }); return m; } },
      BYBIT:   { url: 'https://api.bybit.com/v5/market/tickers?category=spot', useProxy: false, parse: r => { const m={}; ((r?.result?.list)||[]).forEach(it=>{ const s=String(it.symbol||''); if (s.endsWith('USDT')) m[s.replace(/USDT$/,'')] = parseFloat(it.lastPrice); }); return m; } },
      INDODAX: { url: 'https://indodax.com/api/ticker_all', useProxy: true, parse: r => { const m={}; const t=r?.tickers||{}; Object.keys(t).forEach(k=>{ if(/_idr$/i.test(k)){ const sym=k.replace(/_idr$/i,'').toUpperCase(); const last = parseFloat(t[k]?.last); if (isFinite(last)) m[sym]=last; } }); return m; } }
    };

    const $cex = $('#cex-list');
    const $chain = $('#chainSelect');
    const $tbody = $('#tbody');
    const $status = $('#statusText');
    const $btnFetch = $('#btnFetch');
    const $btnExport = $('#btnExport');
    const $btnLoadLocal = $('#btnLoadLocal');
    const $btnImportSeed = $('#btnImportSeed');
    const $btnRpc = $('#btnRpc');
    const $rateCex = $('#rateCex');
    const $rateWeb3 = $('#rateWeb3');
    const $ratePrice = $('#ratePrice');
    const $tableSearch = $('#tableSearch');

    // localStorage keys (prefixed) — use earlier LS_KEYS helpers
    const LS_SNAPSHOT = LS_KEYS.SNAPSHOT;
    function loadSelectedCex(){
      try{
        let arr = IDB_CACHE[LS_KEYS.SELECTED_CEX];
        if (!Array.isArray(arr) || !arr.length){
          // legacy migrate from localStorage
          try { arr = JSON.parse(localStorage.getItem(LS_KEYS.SELECTED_CEX)||'[]'); } catch(_) { arr = []; }
          if (!Array.isArray(arr) || !arr.length){ try { arr = JSON.parse(localStorage.getItem(LS_KEYS.LEGACY_SELECTED_CEX)||'[]'); } catch(_) { arr = []; } }
          if (Array.isArray(arr) && arr.length) trySave(LS_KEYS.SELECTED_CEX, arr);
        }
        return Array.isArray(arr)? arr : [];
      }catch(_){ return []; }
    }
    function loadSnapshot(){ try{ const v = IDB_CACHE[LS_SNAPSHOT]; return (v && typeof v==='object')? v : {}; }catch(_){ return {}; } }
    function saveSnapshot(obj){ trySave(LS_SNAPSHOT, obj); }
    // Upsert to prevent duplicates per (cex, sc)
    function upsertSnapshot(chain, rec){
      const snap = loadSnapshot();
      const list = Array.isArray(snap[chain]) ? snap[chain] : [];
      const scLow = String(rec.sc||'').toLowerCase();
      const cexUp = String(rec.cex||'').toUpperCase();
      let updated = false;
      for (let i=0;i<list.length;i++){
        const it = list[i]||{};
        if (String(it.cex||'').toUpperCase()===cexUp && String(it.sc||'').toLowerCase()===scLow){
          list[i] = { ...it, ...rec, des: (typeof rec.des==='bigint')? String(rec.des): rec.des };
          updated = true; break;
        }
      }
      if (!updated) list.push({ ...rec, des: (typeof rec.des==='bigint')? String(rec.des): rec.des });
      snap[chain] = list; saveSnapshot(snap);
    }
    // One-time compaction to fix old duplicates
    function compactSnapshot(){
      const snap = loadSnapshot();
      const out = {};
      Object.keys(snap||{}).forEach(chain => {
        const seen = new Map();
        (Array.isArray(snap[chain])? snap[chain]: []).forEach(it => {
          const key = `${String(it.cex||'').toUpperCase()}|${String(it.sc||'').toLowerCase()}`;
          seen.set(key, it); // last write wins
        });
        out[chain] = Array.from(seen.values());
      });
      saveSnapshot(out);
    }
    // RPC map per chain
    const LS_RPC='SNAPSHOT_RPC';
    function loadRpc(){ try{ const v = IDB_CACHE[LS_RPC]; return (v && typeof v==='object')? v : {}; }catch(_){ return {}; } }
    function saveRpc(obj){ trySave(LS_RPC, obj||{}); }
    function getRpc(chainKey){ const o=loadRpc(); return (o && o[chainKey]) || (CHAINS[chainKey]||{}).RPC || ''; }
    function appendSnapshot(chain, rec){ try{ upsertSnapshot(chain, rec); }catch(e){ /* debug logs removed */ } }
    // Import snapshot seed helper
    const SNAPSHOT_SEED_URL = 'https://multiscanner.vercel.app/datajson.json';
    async function fetchJsonWithFallback(url){
      // Try direct fetch first
      try {
        const r = await fetch(url, { credentials:'omit' });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      } catch (e) {
        // Fallback via proxy if available
        try {
          const r2 = await $.ajax({ url: prox(url), method:'GET', dataType:'json' });
          return r2;
        } catch (e2) {
          throw e2 || e;
        }
      }
    }
    function normalizeRecord(it, chainFallback){
      const chain = String(it.chain || chainFallback || '').trim();
      const name = String(it.name ?? it.token ?? '').trim();
      const ticker = String((it.ticker ?? it.symbol ?? it.koin ?? '')||'').toUpperCase();
      const sc = String(it.sc ?? it.contract ?? it.address ?? '').trim();
      const des = (it.des ?? it.decimals ?? '');
      const cex = String((it.cex ?? it.exchange ?? '-')||'').toUpperCase();
      return { chain, name, ticker, sc, des, cex };
    }
    async function applySeedObject(obj, onlyChainKey){
      if (!obj || typeof obj !== 'object') throw new Error('Format JSON tidak valid');
      // If wrapped like { SNAPSHOT_DATA_KOIN: {...} }
      const root = (obj && obj.SNAPSHOT_DATA_KOIN) ? obj.SNAPSHOT_DATA_KOIN : obj;
      const knownChains = Object.keys(CHAINS);
      const bag = {}; // chainKey -> array of normalized records
      const lcOnly = onlyChainKey ? String(onlyChainKey).toLowerCase() : '';
      const pushRec = (rec) => {
        if (!rec) return;
        if (!rec.sc) return;
        if (lcOnly && String(rec.chain||'').toLowerCase() !== lcOnly) return;
        const ck = String(rec.chain||'').trim();
        if (!ck) return;
        if (!bag[ck]) bag[ck] = [];
        bag[ck].push(rec);
      };

      // If array provided at root
      if (Array.isArray(root)){
        root.forEach(it => { const rec = normalizeRecord(it, it.chain); pushRec(rec); });
      } else {
        // Object keyed by chain
        Object.keys(root||{}).forEach(chainKey => {
          const arr = Array.isArray(root[chainKey]) ? root[chainKey] : [];
          const isKnown = knownChains.includes(chainKey);
          if (isKnown) {
            if (lcOnly && String(chainKey).toLowerCase() !== lcOnly) return; // skip other chains fast
            arr.forEach(it => { const rec = normalizeRecord(it, chainKey); pushRec(rec); });
          } else if (Array.isArray(root[chainKey])) {
            // Unknown key but array: try to infer chain from each item
            arr.forEach(it => { const rec = normalizeRecord(it, it.chain); pushRec(rec); });
          }
        });
      }

      // Nothing to import
      const chainsToImport = Object.keys(bag);
      if (!chainsToImport.length) return 0;

      // Prepare progress
      let total = 0; chainsToImport.forEach(k => { total += (bag[k]||[]).length; });
      try { setOverlayPhase('Import', total); } catch(_){ }

      // Load snapshot once and merge in-memory
      const snap = loadSnapshot();
      let processed = 0;
      const YIELD_EVERY = 500; // yield to UI every N items

      for (let c=0; c<chainsToImport.length; c++){
        const chainKey = chainsToImport[c];
        const existing = Array.isArray(snap[chainKey]) ? snap[chainKey] : [];
        const map = new Map(); // key: CEX|scLower -> record
        // Seed existing (compacting duplicates)
        for (let i=0;i<existing.length;i++){
          const it = existing[i]||{};
          const scLow = String(it.sc||'').toLowerCase();
          if (!scLow) continue;
          const cexUp = String(it.cex||'').toUpperCase();
          const rec = { ...it };
          if (typeof rec.des==='bigint') rec.des = String(rec.des);
          map.set(`${cexUp}|${scLow}`, rec);
        }
        const addArr = bag[chainKey] || [];
        for (let i=0;i<addArr.length;i++){
          const r = addArr[i]||{};
          const scLow = String(r.sc||'').toLowerCase();
          if (!scLow) { processed++; continue; }
          const cexUp = String(r.cex||'').toUpperCase();
          const key = `${cexUp}|${scLow}`;
          const prev = map.get(key) || {};
          const merged = { ...prev, ...r };
          if (typeof merged.des==='bigint') merged.des = String(merged.des);
          map.set(key, merged);
          processed++;
          if (processed % YIELD_EVERY === 0){
            try { updateOverlayProgress(processed); } catch(_){ }
            await new Promise(r=>setTimeout(r,0));
          }
        }
        snap[chainKey] = Array.from(map.values());
      }
      try { updateOverlayProgress(total); } catch(_){ }
      saveSnapshot(snap);
      return total;
    }

    // Summary badges and search
    function computeCounts(rows){
      const counts = {};
      (rows||[]).forEach(r => { const k = String(r.cex||'-').toUpperCase(); counts[k] = (counts[k]||0)+1; });
      return counts;
    }
    function renderBadges(counts){
      const keys = Object.keys(counts||{});
      if (!keys.length) { $('#summaryBadges').html('<span class="uk-text-meta">No data</span>'); return; }
      let html='';
      keys.sort().forEach(cx => {
        const color = (CEX[cx] && CEX[cx].WARNA) || '#666';
        html += `<span class=\"uk-badge\" style=\"background:${color};\">${cx}: ${counts[cx]}</span>`;
      });
      $('#summaryBadges').html(html);
    }
    function renderSummary(rows){ renderBadges(computeCounts(rows)); }
    function renderRows(rows, chainKey){
      $tbody.empty();
      (rows||[]).forEach((r,idx)=>{
        const price = (isFinite(r.price) ? Number(r.price).toFixed(6) : '-');
        const dep = r.deposit===true? 'ON' : (r.deposit===false? 'OFF' : '-');
        const wd  = r.withdraw===true? 'ON' : (r.withdraw===false? 'OFF' : '-');
        $tbody.append(`<tr>
          <td>${idx+1}</td>
          <td>${r.cex||'-'}</td>
          <td>${String(r.chain||chainKey||'').toUpperCase()}</td>
          <td>${r.token||''}</td>
          <td class="mono">${String(r.symbol||'').toUpperCase()}</td>
          <td class="mono">${r.sc||''}</td>
          <td>${r.decimals||''}</td>
          <td>${isFinite(r.feeWD)? Number(r.feeWD).toFixed(6): (r.feeWD||'-')}</td>
          <td>${r.trade||'-'}</td>
          <td>${dep}</td>
          <td>${wd}</td>
          <td>${price}</td>
        </tr>`);
      });
      renderSummary(rows||[]);
    }
    function setupExport(rows, suffix){
      $btnExport.prop('disabled', !(rows&&rows.length));
      $btnExport.off('click').on('click', function(){
        const header = 'no,cex,chain,nama_token,ticker,sc,decimals,feeWD,trade,deposit,withdraw,price\n';
        const body = (rows||[]).map((r,i)=> [i+1, r.cex||'', r.chain||'', (r.token||''), (r.symbol||'').toUpperCase(), r.sc||'', r.decimals||'', (isFinite(r.feeWD)? r.feeWD : (r.feeWD||'')), r.trade||'', r.deposit, r.withdraw, (isFinite(r.price)? r.price : '')].join(',')).join('\n');
        const blob = new Blob([header+body], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download=`SNAPSHOT_koin_${suffix||'data'}.csv`; a.click(); URL.revokeObjectURL(url);
      });
    }
    function updateSummaryFromVisible(){
      const counts = {};
      $('#tbody tr:visible').each(function(){ const cx = ($(this).find('td').eq(1).text()||'-').toUpperCase(); counts[cx] = (counts[cx]||0)+1; });
      renderBadges(counts);
    }
    $tableSearch.on('input', function(){
      const q = String($(this).val()||'').toLowerCase();
      if (!q) { $('#tbody tr').show(); updateSummaryFromVisible(); return; }
      $('#tbody tr').each(function(){ const t = ($(this).text()||'').toLowerCase(); $(this).toggle(t.indexOf(q)!==-1); });
      updateSummaryFromVisible();
    });

    // Build CEX chips (single row) with saved-count badges per selected chain
    function getSavedCounts(chainKey){
      const snap = loadSnapshot();
      const arr = Array.isArray(snap[chainKey]) ? snap[chainKey] : [];
      const map = new Map(); // cex -> Set of sc
      (arr||[]).forEach(it=>{
        const cx = String(it.cex||'-').toUpperCase();
        const sc = String(it.sc||'').toLowerCase();
        if (!map.has(cx)) map.set(cx, new Set());
        if (sc) map.get(cx).add(sc);
      });
      const c = {};
      map.forEach((set, cx) => { c[cx] = set.size; });
      return c;
    }
    function buildCexChips(){
      const selected = new Set(loadSelectedCex());
      const keys = Object.keys(CEX);
      const counts = getSavedCounts(String($chain.val()));
      let html = ``;
      keys.forEach(k => {
        const color = CEX[k].WARNA || '#333';
        const checked = selected.has(k) ? 'checked' : '';
        const n = counts[String(k).toUpperCase()] || 0;
        html += `<label class=\"uk-margin-small-right\"><input type=\"checkbox\" class=\"uk-checkbox cex-check\" value=\"${k}\" ${checked}> <span class=\"name\" style=\"color:${color};\">${k}</span> <span class=\"uk-badge\" style=\"background:${color};\">${n}</span></label>`;
      });
      $cex.html(html);
    }
    buildCexChips();
    // Rebuild counts when chain changes
    $chain.on('change', buildCexChips);
    // Initialize rate inputs from localStorage
    try {
      const r = loadRate();
      RATE = {
        CEX_DELAY_MS: Number(r.CEX_DELAY_MS ?? RATE.CEX_DELAY_MS),
        WEB3_DELAY_MS: Number(r.WEB3_DELAY_MS ?? RATE.WEB3_DELAY_MS),
        PRICE_DELAY_MS: Number(r.PRICE_DELAY_MS ?? RATE.PRICE_DELAY_MS),
      };
      $rateCex.val(RATE.CEX_DELAY_MS);
      $rateWeb3.val(RATE.WEB3_DELAY_MS);
      $ratePrice.val(RATE.PRICE_DELAY_MS);
    } catch(_) {}
    // Bind changes to persist and apply immediately
    $('#rateCex, #rateWeb3, #ratePrice').on('change', function(){
      const vC = Math.max(0, parseInt($rateCex.val(),10)||0);
      const vW = Math.max(0, parseInt($rateWeb3.val(),10)||0);
      const vP = Math.max(0, parseInt($ratePrice.val(),10)||0);
      RATE = { CEX_DELAY_MS: vC, WEB3_DELAY_MS: vW, PRICE_DELAY_MS: vP };
      saveRate(RATE);
      try { UIkit.notification('Delay updated', {status:'success'}); } catch(_){ }
    });
    // RPC Settings handlers
    $btnRpc.on('click', function(){
      try {
        const cur = loadRpc();
        $('#rpc-ethereum').val(cur.ethereum || (CHAINS.ethereum||{}).RPC || '');
        $('#rpc-bsc').val(cur.bsc || (CHAINS.bsc||{}).RPC || '');
        $('#rpc-polygon').val(cur.polygon || (CHAINS.polygon||{}).RPC || '');
        $('#rpc-arbitrum').val(cur.arbitrum || (CHAINS.arbitrum||{}).RPC || '');
        $('#rpc-base').val(cur.base || (CHAINS.base||{}).RPC || '');
      } catch(_){}
      UIkit.modal('#rpcModal').show();
    });
    $('#btnSaveRpc').on('click', function(){
      const m = {
        ethereum: String($('#rpc-ethereum').val()||'').trim(),
        bsc: String($('#rpc-bsc').val()||'').trim(),
        polygon: String($('#rpc-polygon').val()||'').trim(),
        arbitrum: String($('#rpc-arbitrum').val()||'').trim(),
        base: String($('#rpc-base').val()||'').trim(),
      };
      // Remove empty entries to fallback to defaults
      Object.keys(m).forEach(k => { if (!m[k]) delete m[k]; });
      try { saveRpc(m); UIkit.notification('RPC saved', {status:'success'}); } catch(e){ UIkit.notification(`Save RPC failed: ${e.message||e}`, {status:'danger'}); }
      UIkit.modal('#rpcModal').hide();
    });

    function setStatus(msg){ $status.text(msg||''); }
    function showOverlay(msg){ try{$('#overlay .msg').text(msg||'Processing...'); $('#overlay').show();}catch(_){} }
    function setOverlayPhase(name, total){
      try{
        $('#overlay .phase').text(String(name||'').toUpperCase());
        const $p = $('#ovProgress'); $p.attr('max', Math.max(1, total||1)).val(0);
        $('#overlay .counter').text(`0 / ${total||0} (0%)`);
      }catch(_){ }
    }
    function updateOverlayProgress(done){
      try{
        const $p = $('#ovProgress');
        const max = parseInt($p.attr('max'),10)||1; const val = Math.min(max, Math.max(0, done||0));
        $p.val(val);
        const pct = Math.floor((val/max)*100);
        $('#overlay .counter').text(`${val} / ${max} (${isFinite(pct)?pct:0}%)`);
      }catch(_){ }
    }
    function hideOverlay(){ try{$('#overlay').hide();}catch(_){} }

    // Helpers: alias matching for networks per chain (regex per chain)
    function defaultAliases(chainKey){
      const base = { ethereum:['ETH','ERC20','ETHEREUM'], bsc:['BSC','BEP20','BINANCE SMART CHAIN'], polygon:['MATIC','POLYGON'], base:['BASE'], arbitrum:['ARBITRUM','ARB','ARBETH','ARBITRUM ONE'] };
      return base[chainKey]||[];
    }
    function chainAliases(chainKey){
      const ext = {
        ethereum: ['ETH','ERC20','ETHEREUM'],
        bsc: ['BSC','BEP20','BINANCE SMART CHAIN','BNB SMART CHAIN','BEP-20'],
        polygon: ['POLYGON','MATIC','POLYGON POS','POLYGON (MATIC)','POL'],
        arbitrum: ['ARBITRUM','ARB','ARBITRUM ONE','ARBEVM','ARBITRUMONE','ARB-ETH'],
        base: ['BASE']
      };
      const d = defaultAliases(chainKey);
      const e = ext[chainKey] || [];
      const set = new Set([...(d||[]), ...(e||[])]);
      return Array.from(set);
    }
    function escapeRegex(s){ return String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
    function chainRegex(chainKey){
      const aliases = chainAliases(chainKey);
      if (!aliases.length) return null;
      const alt = aliases.map(escapeRegex).join('|');
      return new RegExp(alt, 'i');
    }
    function matches(chainKey, net){
      const rx = chainRegex(chainKey);
      return rx ? rx.test(String(net||'')) : true;
    }
    function matchesCex(chainKey, net, cex){
      // cex parameter ignored; chain-level regex only
      return matches(chainKey, net);
    }

    // Gate SIGN helper (v4): method + "\n" + path + "\n" + query + "\n" + sha512(body) + "\n" + timestamp
    function sha512Hex(str){ return CryptoJS.SHA512(str).toString(CryptoJS.enc.Hex); }
    function gateSign({ method, path, query = '', body = '', ts, secret }){
      const pre = [
        String(method||'GET').toUpperCase(),
        path,
        query,
        sha512Hex(body||''),
        String(ts)
      ].join('\n');
      return CryptoJS.HmacSHA512(pre, secret).toString(CryptoJS.enc.Hex);
    }

    // Bybit V5 sign helper: preSign = `${ts}${apiKey}${recvWindow}${queryString}`
    function bybitSignV5({ ts, apiKey, recvWindow, queryString = '', secret }){
      const pre = `${ts}${apiKey}${recvWindow}${queryString}`;
      return CryptoJS.HmacSHA256(pre, secret).toString(CryptoJS.enc.Hex);
    }

    // Read API keys from embedded const
    function getKeys(){ return CEX_API; }

    // Fetchers: return [{ cex, chain, token, symbol, sc, decimals, deposit, withdraw, feeWD }]
    const fetchers = {
      async BINANCE(chainKey){
        const k = CEX_API.BINANCE; if(!k?.ApiKey||!k?.ApiSecret) return [];
        const ts = Date.now(); const q = `timestamp=${ts}`;
        const sig = CryptoJS.HmacSHA256(q, k.ApiSecret).toString(CryptoJS.enc.Hex);
        const url = `https://api-gcp.binance.com/sapi/v1/capital/config/getall?${q}&signature=${sig}`;
        const res = await $.ajax({ url: prox(url), headers: { 'X-MBX-ApiKey': k.ApiKey } });
        const out = [];
        (res||[]).forEach(item=>{
          const net = (item.networkList||[]).find(n=> matchesCex(chainKey, n.network, 'BINANCE'));
          if(!net) return;
          out.push({ cex:'BINANCE', chain: chainKey, token: item.name||item.coin||item.asset||'', symbol: String(item.coin||'').toUpperCase(), sc: net.contractAddress||'', decimals:'', deposit: !!net.depositEnable, withdraw: !!net.withdrawEnable, feeWD: parseFloat(net.withdrawFee||0) });
        });
        return out;
      },
      async MEXC(chainKey){
        const k = CEX_API.MEXC; if(!k?.ApiKey||!k?.ApiSecret) return [];
        const ts = Date.now(); const q = `recvWindow=5000&timestamp=${ts}`;
        const sig = CryptoJS.HmacSHA256(q, k.ApiSecret).toString(CryptoJS.enc.Hex);
        const url = `https://api.mexc.com/api/v3/capital/config/getall?${q}&signature=${sig}`;
        const res = await $.ajax({ url: prox(url), headers: { 'X-MEXC-APIKEY': k.ApiKey } });
        const out = [];
        (res||[]).forEach(item=>{
          const net = (item.networkList||[]).find(n=> matchesCex(chainKey, n.network||n.netWork||n.chain||n.name, 'MEXC'));
          if(!net) return;
          out.push({ cex:'MEXC', chain: chainKey, token: item.name||item.coin||'', symbol: String(item.coin||'').toUpperCase(), sc: net.contract || net.contractAddress || '', decimals:'', deposit: !!net.depositEnable, withdraw: !!net.withdrawEnable, feeWD: parseFloat(net.withdrawFee||0) });
        });
        return out;
      },
      async GATE(chainKey){
        // 1) Ambil daftar currencies (public) – kini sudah menyertakan chains[].addr (SC)
        const cur = await $.ajax({ url: prox(`https://api.gateio.ws/api/v4/spot/currencies`) });
        // 2) Optional: ambil withdraw_status (private) untuk fee WD
        let wd = [];
        try {
          const g = CEX_API.GATE || {};
          if (g.ApiKey && g.ApiSecret) {
            const ts = Math.floor(Date.now()/1000);
            const method = 'GET'; const path = '/api/v4/wallet/withdraw_status';
            const sign = gateSign({ method, path, ts, secret: g.ApiSecret });
            wd = await $.ajax({ url: prox(`https://api.gateio.ws${path}`), headers: { 'KEY': g.ApiKey, 'Timestamp': String(ts), 'SIGN': sign } });
          }
        } catch(e) { wd = []; UIkit.notification({message:`GATE withdraw_status gagal: ${e.message||e}`, status:'warning'}); }

        // 3) Gunakan chains dari currencies langsung (addr = SC). Decimals tetap diisi via Web3 nanti.
        const out = [];
        (cur||[]).forEach(item => {
          const symbol = String(item.currency||'').toUpperCase();
          const name = item.name || symbol;
          (item.chains||[]).forEach(ch => {
            const code = String(ch.name||ch.chain||'').toUpperCase();
            if (!matchesCex(chainKey, code, 'GATE')) return;
            let fee = 0; if (Array.isArray(wd) && wd.length){
              const match = wd.find(w => String(w.currency||'').toUpperCase()===symbol);
              const feeMap = match?.withdraw_fix_on_chains || {}; fee = feeMap[code] ?? 0;
            }
            out.push({
              cex:'GATE', chain: chainKey,
              token: name,
              symbol,
              sc: ch.addr || ch.contract_address || '',
              decimals: '',
              deposit: ch.deposit_disabled===false,
              withdraw: ch.withdraw_disabled===false,
              feeWD: parseFloat(fee||0)
            });
          });
        });
        return out;
      },
      async KUCOIN(chainKey){
        const res = await $.ajax({ url: prox('https://api.kucoin.com/api/v3/currencies') });
        const out = [];
        (res?.data||[]).forEach(item=>{
          (item.chains||[]).forEach(ch=>{
            if(!matchesCex(chainKey, ch.chainName, 'KUCOIN')) return;
            out.push({ cex:'KUCOIN', chain: chainKey, token: item.name||item.currency||'', symbol: String(item.currency||'').toUpperCase(), sc: ch.contractAddress||'', decimals:'', deposit: ch.isDepositEnabled===true, withdraw: ch.isWithdrawEnabled===true, feeWD: parseFloat(ch.withdrawalMinFee||ch.withdrawFee||0) });
          });
        });
        return out;
      },
      async OKX(chainKey){
        const res = await $.ajax({ url: prox('https://www.okx.com/api/v5/asset/currencies') });
        const out = [];
        (res?.data||[]).forEach(item=>{
          const chain = item.chain || '';
          if(!matchesCex(chainKey, chain, 'OKX')) return;
          out.push({ cex:'OKX', chain: chainKey, token: item.name||item.ccy||'', symbol: String(item.ccy||'').toUpperCase(), sc: item.ctAddr||'', decimals:'', deposit: String(item.canDep)==='true', withdraw: String(item.canWd)==='true', feeWD: parseFloat(item.minFee||0) });
        });
        return out;
      },
      async BITGET(chainKey){
        const res = await $.ajax({ url: 'https://api.bitget.com/api/v2/spot/public/coins'});
        const out = [];
        (res?.data||[]).forEach(i=> (i.chains||[]).forEach(ch=>{
          if(!matchesCex(chainKey, ch.chain, 'BITGET')) return;
          out.push({ cex:'BITGET', chain: chainKey, token: i.name||i.coin||'', symbol: String(i.coin||'').toUpperCase(), sc: ch.contractAddress||'', decimals:'', deposit: ch.rechargeable==='true', withdraw: ch.withdrawable==='true', feeWD: parseFloat(ch.withdrawFee||0) });
        }));
        return out;
      },
      async BYBIT(chainKey){
        const b = CEX_API.BYBIT || {};
        if (!b.ApiKey || !b.ApiSecret) return [];
        const ts = Date.now().toString(); const recvWindow='5000'; const query='';
        const sign = bybitSignV5({ ts, apiKey:b.ApiKey, recvWindow, queryString: query, secret:b.ApiSecret });
        const res = await $.ajax({ url: `https://api.bybit.com/v5/asset/coin/query-info`, headers: {
          'X-BAPI-SIGN-TYPE': '2',
          'X-BAPI-SIGN': sign,
          'X-BAPI-API-KEY': b.ApiKey,
          'X-BAPI-TIMESTAMP': ts,
          'X-BAPI-RECV-WINDOW': recvWindow
        }});
        const data = res?.result?.rows || res?.result?.list || res?.result || [];
        const out=[];
        (data||[]).forEach(row => {
          const coin = row?.coin || row?.name || row?.symbol || '';
          const chains = row?.chains || row?.chainInfos || [];
          (chains||[]).forEach(ch => {
            const net = ch?.chain || ch?.chainType || ch?.name || '';
            if (!matchesCex(chainKey, net, 'BYBIT')) return;
            out.push({ cex:'BYBIT', chain: chainKey, token: String(coin||''), symbol: String(coin||'').toUpperCase(), sc: ch?.contractAddress || '', decimals:'', deposit: ch?.depositable===true || ch?.canDeposit===true, withdraw: ch?.withdrawable===true || ch?.canWithdraw===true, feeWD: parseFloat(ch?.withdrawFee || ch?.withdrawMinFee || 0) });
          });
        });
        return out;
      },
      async INDODAX(chainKey){
        // Use INDODAX private TAPI getInfo to obtain network mapping per coin
        const k = CEX_API.INDODAX || {};
        if (!k.ApiKey || !k.ApiSecret) return [];
        const ts = Date.now();
        const recvWindow = 5000;
        const method = 'getInfo';
        const body = `method=${method}&timestamp=${ts}&recvWindow=${recvWindow}`;
        const sign = CryptoJS.HmacSHA512(body, k.ApiSecret).toString();
        let res;
        try {
          res = await $.ajax({
            url: prox('https://indodax.com/tapi'),
            type: 'POST',
            headers: { 'Key': k.ApiKey, 'Sign': sign },
            data: body
          });
        } catch(e){ return []; }
        const networkMap = res?.return?.network || {};
        const out = [];
        // Build snapshot index by chain+symbol for enrichment
        let snapBySym = new Map();
        try {
          const snap = loadSnapshot();
          const arr = Array.isArray(snap[chainKey]) ? snap[chainKey] : [];
          arr.forEach(it => {
            const sym = String(it.ticker || it.symbol || '').toUpperCase();
            if (sym) snapBySym.set(sym, it);
          });
        } catch(_){}
        // Iterate network mapping and filter by selected chain aliases
        Object.keys(networkMap||{}).forEach(symRaw => {
          const sym = String(symRaw||'').toUpperCase();
          const netVal = networkMap[symRaw];
          const nets = Array.isArray(netVal) ? netVal : [netVal];
          // Pick any network alias that matches this chain
          const hit = (nets||[]).some(n => matchesCex(chainKey, n, 'INDODAX'));
          if (!hit) return;
          const base = { cex:'INDODAX', chain: chainKey, token: sym, symbol: sym, sc:'', decimals:'', deposit: null, withdraw: null, feeWD: 0 };
          const snapIt = snapBySym.get(sym);
          if (snapIt) {
            base.sc = snapIt.sc || '';
            base.decimals = snapIt.des || snapIt.decimals || '';
            base.token = String(snapIt.name || base.token).trim();
          }
          out.push(base);
        });
        return out;
      }
    };

    async function fetchBulkPrices(selectedCex, onStep){
      const maps = {};
      for (let i=0;i<selectedCex.length;i++){
        const cex = selectedCex[i];
        const cfg = PRICE_SOURCES[cex];
        try {
          if (cfg && cfg.url) {
            const url = (cfg.useProxy===false) ? cfg.url : prox(cfg.url);
            const r = await $.ajax({ url });
            maps[cex] = (cfg.parse||(()=>({})))(r) || {};
          } else { maps[cex] = {}; }
        } catch(e){ maps[cex] = maps[cex] || {}; try{ onStep && onStep(i+1, cex, e.message||e); }catch(_){} }
        await new Promise(r=>setTimeout(r, RATE.PRICE_DELAY_MS));
        try{ onStep && onStep(i+1, cex); }catch(_){ }
      }
      return function getPrice(cex, base){ const b=String(base||'').toUpperCase(); const m=maps[cex]||{}; const v=m[b]; return (isFinite(v)? v : null); };
    }

    async function fetchAll(){
      const selectedCex = $('.cex-check:checked').map(function(){return this.value;}).get();
      const chainKey = String($chain.val());
      if(!selectedCex.length){ UIkit.notification('Pilih minimal 1 CEX', {status:'warning'}); return; }
      if(!chainKey){ UIkit.notification('Pilih chain', {status:'warning'}); return; }

      $btnFetch.prop('disabled', true); $btnExport.prop('disabled', true);
      $tbody.empty(); setStatus('Fetching...');

      // Build snapshot map (chain+sc -> record) for decimals lookup
      const snap = loadSnapshot();
      const prevSnap = Array.isArray(snap[chainKey]) ? snap[chainKey] : [];
      const snapBySc = new Map(); prevSnap.forEach(s=>{ const sc=String(s.sc||''); if(/^0x[a-fA-F0-9]{40}$/.test(sc)) snapBySc.set(sc.toLowerCase(), s); });

      let rows = [];
      showOverlay('Menyiapkan fetch...');
      setOverlayPhase('Fetch CEX', selectedCex.length);
      for (let i=0;i<selectedCex.length;i++){
        const cx = selectedCex[i];
        const msg = `Fetching ${cx} (${i+1}/${selectedCex.length})...`;
        setStatus(msg); showOverlay(msg); updateOverlayProgress(i);
        try{
          if ((cx==='BINANCE'||cx==='MEXC')){ const k=CEX_API[cx]; if(!k?.ApiKey||!k?.ApiSecret){ UIkit.notification(`${cx}: tidak ada API Key embedded`, {status:'warning'}); continue; } }
          const fn = fetchers[cx]; if(!fn) continue; const part = await fn(chainKey); rows = rows.concat(part||[]);
        }catch(e){ UIkit.notification({message:`CEX ${cx} gagal [FETCH_CEX]: ${e.status||''} ${e.message||e}`, status:'danger'}); }
        await new Promise(r=>setTimeout(r, RATE.CEX_DELAY_MS));
      }
      updateOverlayProgress(selectedCex.length);

      // Dedup per (cex, chain, symbol)
      const key = r => `${r.cex}|${r.chain}|${String(r.symbol||'').toUpperCase()}`;
      const map = new Map(); rows.forEach(r=>{ if(!map.has(key(r))) map.set(key(r), r); });
      rows = Array.from(map.values());

      // Initial render: show rows immediately after CEX fetch and NameMap filtering
      $tbody.empty();
      rows.forEach((r,idx)=>{
        // Prefer decimals from snapshot before rendering
        const scKey = String(r.sc||'').toLowerCase();
        const snapRec = snapBySc.get(scKey);
        if (snapRec && (snapRec.des!==undefined && snapRec.des!=='' && snapRec.des!=null)) {
          r.decimals = r.decimals || snapRec.des;
        }
        const price = (isFinite(r.price) ? Number(r.price).toFixed(6) : '-');
        const dep = r.deposit===true? 'ON' : (r.deposit===false? 'OFF' : '-');
        const wd  = r.withdraw===true? 'ON' : (r.withdraw===false? 'OFF' : '-');
        const rowId = `row-${r.cex}-${String(r.symbol||'').toUpperCase()}-${r.chain}`.replace(/[^a-zA-Z0-9_-]/g,'');
        // Hanya log yang lengkap → logging dipindahkan ke fase decimals (snapshot/web3)
        $tbody.append(`<tr id="${rowId}">
          <td>${idx+1}</td>
          <td>${r.cex}</td>
          <td>${String(r.chain).toUpperCase()}</td>
          <td>${r.token||''}</td>
          <td class="mono">${String(r.symbol||'').toUpperCase()}</td>
          <td class="mono">${r.sc||''}</td>
          <td class="cell-decimals">${r.decimals||''}</td>
          <td>${isFinite(r.feeWD)? Number(r.feeWD).toFixed(6): '-'}</td>
          <td class="cell-trade">${r.trade||'-'}</td>
          <td>${dep}</td>
          <td>${wd}</td>
          <td class="cell-price">${price}</td>
        </tr>`);
      });

      // Fill decimals/name/symbol from snapshot; resolve missing via web3
      const rpc = getRpc(chainKey);
      if (rpc) {
        try {
          showOverlay('Resolving decimals via cache/web3...');
          setOverlayPhase('Checking Decimals Smart Contract', rows.length);
          const web3 = new Web3(new Web3.providers.HttpProvider(rpc));
          const abi = [{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"type":"function"}, {"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"type":"function"}, {"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"type":"function"}];
          for (let i=0;i<rows.length;i++){
            const r = rows[i];
            const sc = String(r.sc||'');
            const name = r.token || r.symbol || '';
            // Skip Web3 for INDODAX rows per requirement
            if (String(r.cex||'').toUpperCase()==='INDODAX') { updateOverlayProgress(i+1); continue; }
            if(!/^0x[a-fA-F0-9]{40}$/.test(sc)) { continue; }
            const snapCached = snapBySc.get(sc.toLowerCase());
            if (snapCached && (snapCached.des!==undefined && snapCached.des!=='' && snapCached.des!=null)){
              r.decimals = r.decimals||snapCached.des||'';
              r.token = r.token||snapCached.koin||r.token;
              // Update table cell
              try { const row = document.getElementById(`row-${r.cex}-${String(r.symbol||'').toUpperCase()}-${r.chain}`.replace(/[^a-zA-Z0-9_-]/g,'')); if(row){ const cell=row.querySelector('.cell-decimals'); if(cell) cell.textContent = r.decimals||''; } } catch(_){ }
              // Log hanya jika lengkap: chain, nama koin, SC, DES
              try { const nm=r.token||r.symbol||''; if (r.chain && nm && sc && r.decimals!=='' && r.decimals!=null) { /* debug logs removed */ } } catch(_){ }
              continue;
            }
            if (r.decimals!==undefined && r.decimals!=='' && r.decimals!=null) {
              try { const nm=r.token||r.symbol||''; if (r.chain && nm && sc) { /* debug logs removed */ } } catch(_){ }
              continue;
            }
            try{ const c = new web3.eth.Contract(abi, sc); const [d, nm, sb] = await Promise.all([ c.methods.decimals().call(), c.methods.name().call().catch(()=>''), c.methods.symbol().call().catch(()=>r.symbol) ]); r.decimals=d; if(nm) r.token=nm; if(sb) r.symbol=sb; 
              // incremental upsert to SNAPSHOT
              try { const ksym = String(r.symbol||'').toUpperCase(); const kname = String(r.token||''); upsertSnapshot(chainKey, { chain:r.chain, name: kname, ticker: ksym, sc:r.sc, des:d, cex:r.cex }); snapBySc.set(sc.toLowerCase(), { chain:r.chain, name: kname, ticker: ksym, sc:r.sc, des:d, cex:r.cex }); } catch(_){ }
              // Log hanya jika lengkap setelah web3
              try { const name2=r.token||r.symbol||''; if (r.chain && name2 && sc && d!=='' && d!=null) { /* debug logs removed */ } } catch(_){ }
            }catch(e){ r.decimals = r.decimals || ''; UIkit.notification({message:`WEB3 gagal [${(r.symbol||r.token||'').toUpperCase()} ${sc.slice(0,8)}...] : ${e.message||e}`, status:'warning'}); }
            await new Promise(r=>setTimeout(r, RATE.WEB3_DELAY_MS));
            updateOverlayProgress(i+1);
          }
        }catch(e){ /* debug logs removed */ }
      }

      // Prices + trade status (bulk per CEX)
      try{ showOverlay('Fetching prices (bulk)...'); }catch(_){ }
      setOverlayPhase('Bulk Prices', selectedCex.length);
      const getPrice = await fetchBulkPrices(selectedCex, (idx, cex, err)=>{
        if (err) UIkit.notification({message:`PRICE_BULK gagal [${cex}]: ${err}`, status:'warning'});
        updateOverlayProgress(idx);
      });
      rows.forEach(r => { r.price = getPrice(r.cex, r.symbol); r.trade = (r.price!=null) ? 'ON' : 'OFF'; });
      showOverlay('Rendering results...');

      // Render table (centralized)
      renderRows(rows, chainKey);

      setStatus(`${rows.length} tokens.`);
      try { renderSummary(rows); } catch(_){}
      $btnFetch.prop('disabled', false);
      setupExport(rows, String($chain.val()).toUpperCase());
      hideOverlay();

      // Persist final snapshot (upsert per (cex, sc))
      try {
        rows.forEach(r => { if (r.sc && r.decimals!==undefined && r.decimals!=='' && r.decimals!=null) upsertSnapshot(chainKey, { chain:r.chain, name: String(r.token||''), ticker: String(r.symbol||'').toUpperCase(), sc:r.sc, des:r.decimals, cex:r.cex }); });
      } catch(_){ }

      // Export
      $btnExport.off('click').on('click', function(){
        const header = 'no,cex,chain,nama_token,ticker,sc,decimals,feeWD,trade,deposit,withdraw,price\n';
        const body = rows.map((r,i)=> [i+1, r.cex, r.chain, (r.token||''), (r.symbol||'').toUpperCase(), r.sc||'', r.decimals||'', (isFinite(r.feeWD)? r.feeWD : ''), r.trade||'', r.deposit, r.withdraw, (isFinite(r.price)? r.price : '')].join(',')).join('\n');
        const blob = new Blob([header+body], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download=`SNAPSHOT_koin_${String($chain.val()).toUpperCase()}.csv`; a.click(); URL.revokeObjectURL(url);
      });
    }

    $('#btnFetch').on('click', fetchAll);
    // Import snapshot seed from URL → merge into localStorage
    $btnImportSeed.on('click', async function(){
      try{
        const url = SNAPSHOT_SEED_URL;
        if (!url || !/^https?:\/\//i.test(url)) { UIkit.notification('❌ URL seed tidak tersedia/valid', {status:'danger'}); return; }
        const onlyChain = String($chain.val()||'').trim();
        showOverlay(`Mengambil snapshot awal (${onlyChain.toUpperCase()||'ALL'})...`);
        setOverlayPhase('Download', 1);
        updateOverlayProgress(1);
        const data = await fetchJsonWithFallback(url);
        showOverlay('Menyimpan ke Database...');
        setOverlayPhase('Import', 1);
        const n = await applySeedObject(data, onlyChain);
        try { UIkit.notification(`✅ Import ${onlyChain.toUpperCase()} — ${n||0} item`, {status:'success'}); } catch(_){ }
        // Refresh CEX chips count for current chain
        try { buildCexChips(); } catch(_){ }
      } catch(e){
        try { UIkit.notification(`❌ Import gagal: ${e.message||e}`, {status:'danger'}); } catch(_){ }
      } finally {
        hideOverlay();
      }
    });
    // Load tokens from Database (no API calls)
    $btnLoadLocal.on('click', function(){
      try{
        const chainKey = String($chain.val());
        if(!chainKey){ UIkit.notification('Pilih chain dahulu', {status:'warning'}); return; }
        showOverlay('Loading from Database...'); setOverlayPhase('Local Rows', 1); updateOverlayProgress(1);
        const snap = loadSnapshot();
        const s = Array.isArray(snap[chainKey]) ? snap[chainKey] : [];
        // Filter by selected CEX (if any)
        const selectedCexInitial = $('.cex-check:checked').map(function(){return this.value;}).get();
        const sFiltered = selectedCexInitial.length ? s.filter(it => selectedCexInitial.includes(String(it.cex||'').toUpperCase())) : s;
        let rows = sFiltered.map(it => ({
          cex: it.cex || '-',
          chain: it.chain || chainKey,
          token: String(it.name || it.token || '').trim(),
          symbol: String(it.ticker || it.koin || it.symbol || '').toUpperCase(),
          sc: it.sc || '',
          decimals: it.des || it.decimals || '',
          feeWD: '', deposit: '', withdraw: '', trade: '', price: ''
        }));
        // Render table quickly (local)
        renderRows(rows, chainKey);
        setStatus(`${rows.length} tokens (Local)`);
        try { renderSummary(rows); } catch(_){}
        // Fetch bulk prices for checked CEX and fill into table
        (async ()=>{
          try {
            // Determine which CEX to fetch prices for: use selected chips if any, otherwise infer from rows
            let selectedCex = $('.cex-check:checked').map(function(){return this.value;}).get();
            if (!selectedCex.length) {
              const set = new Set(); rows.forEach(r => { const cx=String(r.cex||'').toUpperCase(); if (cx && PRICE_SOURCES[cx]) set.add(cx); });
              selectedCex = Array.from(set.values());
            }
            setOverlayPhase('Bulk Prices', selectedCex.length); updateOverlayProgress(0);
            if (!selectedCex.length) { UIkit.notification('Tidak ada CEX untuk diambil harganya', {status:'warning'}); return; }
            const getPrice = await fetchBulkPrices(selectedCex, (idx, cex, err)=>{
              if (err) UIkit.notification({message:`PRICE_BULK gagal [${cex}]: ${err}`, status:'warning'});
              updateOverlayProgress(idx);
            });
            rows.forEach(r => { r.price = getPrice(r.cex, r.symbol); r.trade = (r.price!=null) ? 'ON' : 'OFF'; });
            showOverlay('Rendering results...');
            renderRows(rows, chainKey);
            setStatus(`${rows.length} tokens (DB + Price)`);
            try { renderSummary(rows); } catch(_){}
            setupExport(rows, `local_${String($chain.val()).toUpperCase()}`);
          } catch(e) {
            UIkit.notification({message:`Bulk price gagal: ${e.message||e}`, status:'warning'});
          } finally {
            hideOverlay();
          }
        })();
      }catch(e){ UIkit.notification({message:`Load DB gagal: ${e.message||e}`, status:'danger'}); }
      finally { /* overlay dismissed in async block after price fetch */ }
    });
  })();
  </script>
</body>
</html>
